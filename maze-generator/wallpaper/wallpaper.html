<!DOCTYPE html>
<html>
    <head>
        <title>Maze Generator</title>
        <style>
            html, body {
                width: 100%;
                height: 100%;
                margin: 0;
                background-color: black;
                color: white;
                overflow: hidden;
            }

            button {
                border: 1px solid white;
                padding: 1%;
                color: white;
                background-color: black;
                transition-duration: 0.4s;
                cursor: pointer;
                margin-top: 1%;
            }

            button:hover {
                color: black;
                background-color: white;
            }

            button:active {
                transform: scale(0.95);
            }

            .content {
                position: absolute;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
                flex-direction: column;
            }

            .message {
                position: absolute;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
            }

            .buttons {
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: center;
                column-gap: 2%;
            }
        </style>
    </head>
    <body>
        <div class="message">
            <p>Generating...</p>
        </div>
        <div class="content">
            <canvas></canvas>
            <!-- <div class="buttons">
                <button class="skeleton">Toggle Skeleton</button>
                <button class="borders">Toggle Borders</button>
                <button class="update">Update Maze</button>
            </div> -->
        </div>
        <script>
            const $ = selector => document.querySelector(selector)

            const dimX = 40
            const dimY = 25
            const cellDim = 50
            let origin = { x : dimX - 1, y : dimY - 1}

            let border = true
            let skele = false

            const canvas = $('canvas')
            const ctx = canvas.getContext('2d')

            canvas.height = cellDim * dimY
            canvas.width = cellDim * dimX

            const drawNodes = () => {
                for (let y = 0; y < dimY; y++) {
                    for (let x = 0; x < dimX; x++) {
                        if (x == origin.x && y == origin.y) ctx.fillStyle = 'red'
                        else ctx.fillStyle = 'white'
                        ctx.beginPath()
                        ctx.arc(cellDim / 2 + x * cellDim, cellDim / 2 + y * cellDim, 5, 0, 2 * Math.PI)
                        ctx.fill()
                    }
                }
            }

            const clear = () => {
                ctx.fillStyle = 'black'
                ctx.fillRect(0, 0, canvas.width, canvas.height)
            }

            let horizontalEdges = new Array(dimY).fill('').map(() => new Array(dimX - 1).fill('d'))
            let verticalEdges = new Array(dimX - 1).fill('').map(() => new Array(dimY).fill(''))
            for (let i = 0; i < dimY - 1; i++) {
                verticalEdges[i][dimX - 1] = 's'
            }

            const drawEdges = () => {
                ctx.strokeStyle = 'white'
                ctx.lineWidth = 5
                ctx.beginPath()
                for (let y = 0; y < horizontalEdges.length; y++) {
                    for (let x = 0; x < horizontalEdges[y].length; x++) {
                        if (horizontalEdges[y][x] == 'd') {
                            ctx.moveTo(0.65 * cellDim + cellDim * x, cellDim / 2 + cellDim * y)
                            ctx.lineTo(0.35 * cellDim + cellDim * (x + 1), cellDim / 2 + cellDim * y)
                            ctx.lineTo(0.30 * cellDim + cellDim * (x + 1), 0.45 * cellDim + cellDim * y)
                            ctx.lineTo(0.30 * cellDim + cellDim * (x + 1), 0.55 * cellDim + cellDim * y)
                            ctx.lineTo(0.35 * cellDim + cellDim * (x + 1), cellDim / 2 + cellDim * y)
                        } else if (horizontalEdges[y][x] == 'a') {
                            ctx.moveTo(0.35 * cellDim + cellDim * (x + 1), cellDim / 2 + cellDim * y)
                            ctx.lineTo(0.65 * cellDim + cellDim * x, cellDim / 2 + cellDim * y)
                            ctx.lineTo(0.70 * cellDim + cellDim * x, 0.45 * cellDim + cellDim * y)
                            ctx.lineTo(0.70 * cellDim + cellDim * x, 0.55 * cellDim + cellDim * y)
                            ctx.lineTo(0.65 * cellDim + cellDim * x, cellDim / 2 + cellDim * y)
                        }
                    }
                }
                for (let y = 0; y < verticalEdges.length; y++) {
                    for (let x = 0; x < verticalEdges[y].length; x++) {
                        if (verticalEdges[y][x] == 's') {
                            ctx.moveTo(cellDim / 2 + cellDim * x, 0.65 * cellDim + cellDim * y)
                            ctx.lineTo(cellDim / 2 + cellDim * x, 0.35 * cellDim + cellDim * (y + 1))
                            ctx.lineTo(0.45 * cellDim + cellDim * x, 0.30 * cellDim + cellDim * (y + 1))
                            ctx.lineTo (0.55 * cellDim + cellDim * x, 0.30 * cellDim + cellDim * (y + 1))
                            ctx.lineTo(cellDim / 2 + cellDim * x, 0.35 * cellDim + cellDim * (y + 1))
                        } else if (verticalEdges[y][x] == 'w') {
                            ctx.moveTo(cellDim / 2 + cellDim * x, 0.35 * cellDim + cellDim * (y + 1))
                            ctx.lineTo(cellDim / 2 + cellDim * x, 0.65 * cellDim + cellDim * y)
                            ctx.lineTo(0.45 * cellDim + cellDim * x, 0.70 * cellDim + cellDim * y)
                            ctx.lineTo(0.55 * cellDim + cellDim * x, 0.70 * cellDim + cellDim * y)
                            ctx.lineTo(cellDim / 2 + cellDim * x, 0.65 * cellDim + cellDim * y)
                        }
                    }
                }
                ctx.stroke()
            }

            const drawBorders = () => {
                ctx.strokeStyle = 'gray'
                ctx.lineWidth = 5
                ctx.beginPath()
                ctx.moveTo(0, 0)
                ctx.lineTo(canvas.width, 0)
                ctx.lineTo(canvas.width, canvas.height - cellDim)
                ctx.moveTo(canvas.width, canvas.height)
                ctx.lineTo(0, canvas.height)
                ctx.lineTo(0, cellDim)
                for (let y = 0; y < horizontalEdges.length; y++) {
                    for (let x = 0; x < horizontalEdges[y].length; x++) {
                        if (horizontalEdges[y][x] == '') {
                            ctx.moveTo(cellDim * (x + 1), cellDim * y)
                            ctx.lineTo(cellDim * (x + 1), cellDim * (y + 1))
                        }
                    }
                }
                for (let y = 0; y < verticalEdges.length; y++) {
                    for (let x = 0; x < verticalEdges[y].length; x++) {
                        if (verticalEdges[y][x] == '') {
                            ctx.moveTo(cellDim * x, cellDim * (y + 1))
                            ctx.lineTo(cellDim * (x + 1), cellDim * (y + 1))
                        }
                    }
                }
                ctx.stroke()
            }

            const drawMaze = () => {
                clear()
                if (skele) {
                    drawNodes()
                    drawEdges()
                }
                if (border) {
                    drawBorders()
                }
            }

            const updateMaze = () => {
                let dir = ''
                if (Math.round(Math.random()) == 0) {
                    if (Math.round(Math.random()) == 0) {
                        if (origin.x + 1 < dimX) {
                            origin.x++
                            dir = 'd'
                        } else {
                            origin.x--
                            dir = 'a'
                        }
                    } else {
                        if (origin.x - 1 >= 0) {
                            origin.x--
                            dir = 'a'
                        } else {
                            origin.x++
                            dir = 'd'
                        }
                    }
                } else {
                    if (Math.round(Math.random()) == 0) {
                        if (origin.y + 1 < dimY) {
                            origin.y++
                            dir = 's'
                        } else {
                            origin.y--
                            dir = 'w'
                        }
                    } else {
                        if (origin.y - 1 >= 0) {
                            origin.y--
                            dir = 'w'
                        } else {
                            origin.y++
                            dir = 's'
                        }
                    }
                }
                switch (dir) {
                    case 'w':
                        verticalEdges[origin.y][origin.x] = dir
                        break
                    case 's':
                        verticalEdges[origin.y - 1][origin.x] = dir
                        break
                    case 'a':
                        horizontalEdges[origin.y][origin.x] = dir
                        break
                    case 'd':
                        horizontalEdges[origin.y][origin.x - 1] = dir
                        break
                }
                if (origin.x - 1 >= 0 && horizontalEdges[origin.y][origin.x - 1] == 'a') horizontalEdges[origin.y][origin.x - 1] = ''
                if (origin.x < horizontalEdges[origin.y].length && horizontalEdges[origin.y][origin.x] == 'd') horizontalEdges[origin.y][origin.x] = ''
                if (verticalEdges[origin.y - 1]?.[origin.x] == 'w') verticalEdges[origin.y - 1][origin.x] = ''
                if (verticalEdges[origin.y]?.[origin.x] == 's') verticalEdges[origin.y][origin.x] = ''
            }

            window.onload = () => {
                for (let i = 0; i < 5000000; i++) {
                    updateMaze()
                }

                const loop = () => {
                    updateMaze()
                    drawMaze()
                    requestAnimationFrame(loop)
                }
                drawMaze()
                requestAnimationFrame(loop)
            }

            $('.skeleton').onclick = () => {
                skele = !skele
                drawMaze()
            }

            $('.borders').onclick = () => {
                border = !border
                drawMaze()
            }

            $('.update').onclick = () => {
                updateMaze()
                drawMaze()
            }
        </script>
    </body>
</html>